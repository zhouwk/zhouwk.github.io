<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactiveCocoa_Signal]]></title>
    <url>%2F2018%2F06%2F25%2FReactiveCocoa-Signal%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITextField]]></title>
    <url>%2F2018%2F06%2F15%2FUITextField%2F</url>
    <content type="text"><![CDATA[123override func textRect(forBounds bounds: CGRect) -&gt; CGRect &#123; return bounds.insetBy(dx: 10, dy: 10)&#125; 重写该方法用于调整文本的显示区域(非编辑状态)，参数中bounds的解释是The bounding rectangle of the receiver.但是并不是很清楚和谁有关系，测试案例中输出结果有时候为文本框的.bounds,更多是(0, 0, 100, 100)重写该方法之后，会影响到文本框在编辑状态下的展现形式所以编辑状态下的本文区域也要做同样的设置123override func editingRect(forBounds bounds: CGRect) -&gt; CGRect &#123; return bounds.insetBy(dx: 10, dy: 10)&#125;同时，也可以重写其他如下方法来调节相应内容的显示区域12345678910- (CGRect)borderRectForBounds:(CGRect)bounds;- (CGRect)textRectForBounds:(CGRect)bounds;- (CGRect)placeholderRectForBounds:(CGRect)bounds;- (CGRect)editingRectForBounds:(CGRect)bounds;- (CGRect)clearButtonRectForBounds:(CGRect)bounds;- (CGRect)leftViewRectForBounds:(CGRect)bounds;- (CGRect)rightViewRectForBounds:(CGRect)bounds;- (void)drawTextInRect:(CGRect)rect;- (void)drawPlaceholderInRect:(CGRect)rect; CGRect.insertBy(dx, dy) 相对一个CGRect调节偏移，从而形成一个新的CGRect12345let rect = CGRect(x: 10, y: 10, width: 100, height: 100)print(rect.insetBy(dx: 10, dy: 10))//(20.0, 20.0, 80.0, 80.0)print(rect.insetBy(dx: -10, dy: -10))//(0.0, 0.0, 120.0, 120.0)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码量统计]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%BB%A3%E7%A0%81%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[之前有过一次面试被问到：“项目中大约有多少类和多少行代码”，当时心里就…了，这怎么回答，因为着实估算不出来啊，而且其他人负责的模块更不好估算啊。所以后来上网特意找了下相关的终端命令。1234// 统计文件夹下文件的数量，包括子文件夹下的ls -lR|grep &quot;^-&quot;|wc -l // 统计项目中指定文件后缀名的代码行数(这个也是不准确的，因为包括了空行)find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; -or -name &quot;*.xib&quot; &quot;)&quot; -print | xargs wc -l写软件著作权申请书的时候也会用到这两个终端命令，因为填写这两个数据。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>代码量统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际化]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[国际化本身并不是一个复杂的东西，所以只会简要介绍其中的一些点。 国际化基础配置还是要简单介绍一下项目国际化需要的配置以及XIB和代码中字符串的国际化。首先我们要在PROJECT-&gt;Localizations中添加所要支持的语言，同时会有自动弹框选中需要国际化的XIB文件。 | 完成之后，在相应的XIB文件locallzation配置中，选择需要支持的语言，xcode会在XIB文件下生成对应的国际化文件，内容格式(文本控件ID.txt = &quot;该语言下的文字&quot;;)XIB国际化有一个关于更新内容的问题会在XIB国际化脚本中介绍对于代码中字符串国际化，我们需要新建一个字符文件,command + n,在弹出的选择面板中搜索string，选中图中编辑的文件模板，并命名Localizable.strings接下来的操作和上述XIB的类似，在文件配置中选择国际化需要支持的语言，同时会为该文件自动生成相应语言的语言文件(Localizable.strings(对应语言))，文件内容为(需要国际化的文字 = &quot;该语言下的文字&quot;;)文字key就是代码中的NSLocalizedString(key, comment: “”)同样也面临一个更新繁琐的问题会在genStrings的使用中介绍 XIB国际化脚本一个项目的实现不可能是一步到位的，必然会对XIB进行多次修改，那么问题就来了： 如果新增/删除一个Label，xcode并不会自动更新该XIB对应的国际化文件，我们为了更新这个Label的国际化，方式①在XIB的配置界面中Localization中取消所有的语言选中，再重新勾选，使XIB重新进行国际化；方式②以sourceCode的方式打开这个XIB，找到个Label的id，手动增加(id.text = &quot;该语言下的文字&quot;)或者删除这个Label的国际化信息。难道每次更新XIB有关文本控件的时候，都要进行这个操作，显然这是很恶心的。 接上，如果选择了方式①，重新勾选该XIB支持的语言之后，会有一个弹框提示你是使用之前的国际化文件还是替换掉国际化文件, 如果勾选了Use File，那么国际化文件还是得不到更新，那只能选择Replace File，但是你会发现，这个操作会把之前已经国际化好的内容给干掉，再次被坑。 为了避免上面提到的问题，有人给出了一个XIB自动国际化的脚本AutoGenStrings，在项目的Build Phases-&gt;New Run Script Phase配置脚本路径好处： 在XIB中添加UILabel，编译之后，会自动在添加其对应的id.text = &quot;等待国际化的文字&quot; 在XIB中删除UIlabel，编译之后，会自动注释掉其对应的id.text = &quot;该语言下的文字&quot; 是增量修改，并不会覆盖之前已经国际化好的内容 提供时间日志，虽然没什么用 genStrings的使用在前面已经简单介绍了代码中字符串的国际化,但是如果我们每次在代码中增加/删除NSLocalizedString(key, comment: &quot;&quot;)，就要到Localizable.strings(对应语言)文件中去添加/删除相应的&quot;key&quot; = &quot;该语言下的文字&quot;;，也是相当恶心的。终端genStringsd指令的作用就是遍历项目中NSLocalizedString(&quot;key&quot;, comment: &quot;&quot;)字符串，并且用遍历的数据覆盖掉Localizable.strings(对应语言)文件，不足之处就不能增量修改，而是覆盖重写，之前已经国际化好的内容会被覆盖掉。终端命令的使用方式，到项目的根目录下， swift项目终端输入1find ./ -name &quot;*.swift&quot; -print0 | xargs -0 genstrings -o en.lproj en.lproj这是英语文件，我们在配置项目语言的时候可以看到每个语言的缩写，从而生成其他的语言文件 OC项目终端输入1find ./ -name *.m -print0 | xargs -0 genstrings -o en.lproj en.lproj解释同上。 复杂字符串的国际化对于一些包含可变内容的字符串就不能使用NSLocalizedString(&quot;key&quot;, comment: &quot;&quot;)的方式了。看一下和手机系统当前语言相关的两个API。API-11Bundle.main.preferredLocalizationsa subset of this bundle’s localizations, re-ordered into the preferred order for this process’s current execution environment; the main bundle’s preferred localizations indicate the language (of text) the user is most likely seeing in the UI BundleAPI解释从解释中可以看出它是APP本地化的一个子集，并且根据偏好语言列表重新排序。最有可能(不是100%)指示出APP要显示的语言，项目中也是用该API也进行包含可变子字符串的国际化。API-21NSLocale.preferredLanguages An ordered list of the user’s preferred languages. NSLocalAPI解释它所指示的是手机中的用户偏好语言列表，每一个元素为语言-地区,比如设置语言法语，地区中国即是fr-CN实际中，也有很多人使用该它就是当前语言的判断，但是这是错误的，即使你看到了正确的结果，也是因为没有相应情况的测试用例。我们手机上设置当前语言的时候，或者把偏好语言列表进行排序的时候，手机当前语言一定是它所返回列表中的第一个语言信息，那为什么不能根据它来进行国际化呢？假如我们APP支持的语言为中文、英文，我们把手机当前语言的语言设置为法语，可以打印他们的返回值如下：1234print(Bundle.main.preferredLocalizations)//["en"]print(NSLocale.preferredLanguages)//["fr-CN", "en-CN", "zh-Hans-CN"]从结果看，他们的差别就很明显了，因为APP并不支持法语，API-1并没有包含法语，那为什么是英文呢？在前面提到了API-1不仅和本地化有关，还会根据偏好语言列表进行排序，列表中APP支持的第一语言就是英文了，而API-2就只是用户偏好语言列表，和APP无关。如果我们把APP支持的语言设置为中文、英文、法语，那打印结果如下：1234print(Bundle.main.preferredLocalizations)//["fr"]print(NSLocale.preferredLanguages)//["fr-CN", "en-CN", "zh-Hans-CN"]这就是前面提到缺少的测试用例了。 图片的国际化图片的国际化有两种方式方式一是和XIB和.string文件国际化一样，在侧边栏选择需要支持的语言，然后到项目中语言.lproj的文件夹中放该语言下的图片，但是图片就不能放到asset中了，这也是缺点，失去了asset对该图片的优化处理，而且比较繁琐，要多次到语言.lproj文件夹中替换，同时2x、3x还要同样处理推荐方式二:使用复杂字符串的国际化判断当前语言，UIimage(named: &quot;语言图片.png&quot;) Info.plist的国际化同代码中字符串国际化一样，新建一个__.string文件，然后在文件侧边栏选择需要支持的语言，同样会自动生成相应的__.string(语言)的国际化文件，以Source code的方式打开Info.plist文件把属性名粘贴出来，添加到国际化文件中完成国际化1CFBundleName = &quot;其他语言下的名字&quot;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[widget]]></title>
    <url>%2F2018%2F05%2F24%2Fwidget%2F</url>
    <content type="text"><![CDATA[实际上这并不是我首次在项目中使用到widget，先后在两个项目中涉及到widget，首次使用应该是16年的项目中。说来有些惭愧，虽然已经在两个项目中使用widget，但是除了业务逻辑，针对widget的逻辑(基本是UI逻辑)都只是简单的粘贴复制，并没有对其中的相关API进行仔细分析，所以当时为了调节和需求对应的效果，盲目的模仿一些文章调节参数。当时碰到的比较棘手的问题算只有两个： iOS9 -&gt; iOS10： 因为在iOS10之后，widget需要重新进行适配 iOS10-&gt; Now: 折叠/展开按钮的状态控制。 首先还是要提一下自己的一个关于widget生命周期的认知错误，挺长一段时间我都认为，widget在拉下来的时候并不会都执行viewDidLoad(),而是有点类似UITabBarController&#39;chilerViewContoller,只创建一次，后面每次点击item都是重新appear。基于这样的错误思维，实际开发中，基本没有在viewDidLoad()中加入什么逻辑，而是把相应的逻辑都转移到了viewWillAppear()中。 在iOS10之后，苹果引入新的API来管理控制widgetUI，起决定作用的是一个枚举(NCWidgetDisplayMode)和对协议(NCWidgetProviding)的补充。 NCWidgetDisplayMode1234567@available(iOS 10.0, *)public enum NCWidgetDisplayMode : Int &#123; case compact // Fixed height case expanded // Variable height&#125; 与其对应的是NSExtensionContext下的两个扩展属性widgetLargestAvailableDisplayMode、widgetActiveDisplayMode widgetLargestAvailableDisplayMode(ios10)先看下官方的部分使用解释:Widgets can change the largest display mode they make available from the default ‘NCWidgetDisplayModeCompact’ by messaging the extension context.Modifying this property more than once during the lifetime of the widget (perhaps due to changes in the amount of available content) is supported. 粗暴理解下，该属性用于控制widget的最大显示模式，并且可以根据显示内容的改变它的值。默认= .compact，widget处于一种固定高度的状态110pt(并未在所有机型上验证)，且无法修改，widget会隐藏展开/折叠按钮。于是就引出了上面提到的第一个问题，在&lt;= iOS9的时候，widget高度都是直接使用preferredContentSize控制，但是用户升级到&gt;= iOS10之后，preferredContentSize便无法控制它的高度，一直处于110pt状态，导致内容无法全部显示。当= .expanded，此时widget处于高度可变的状态，且会显示展开/折叠按钮，但是按钮当前的状态和它无关(这也是我曾经的一个误区)。注意一点：如果手动设置该属性，必须要在后面设置相应状态的preferredContentSize属性，否则会出现异常的结果，见遇到的坑所以可以根据需求进行相应的设置，如果高度固定，且只有110pt，那使用默认就好，否则只能设置.expanded。假设场景：最大会在widget中显示四行四列16个model的方格布局，在从服务器中拿到数据之后，如果不超过4个model，直接设置.compact隐藏掉展开/折叠按钮，多于4个model的时候，设置.expanded显示展开/折叠按钮。 widgetActiveDisplayMode(iOS10)这是个read-only属性，对应于widget所处于的状态和展开/折叠按钮的状态，= .compactwidget处于已折叠状态，按钮显示展开，= .expandedwidget处于已展开的状态，按钮显示折叠。从现象上看它的值(状态)是被手机单独记录下来的，并不是每次拉下来widget都是回到默认值(事实上它也没有默认值)，而是保留了上次点击展开/折叠按钮所触发的状态改变假设场景：项目中可以在请求到服务器model后，根据该属性的值来决定要显示多少个model，设置多大的preferredContentSize,= .compact显示部分，= .expanded显示全部。但是如果处理不当，widget的状态可能会和你设置的相应状态下的preferredContentSize不匹配，见遇到的坑 NCWidgetProviding先看一下该协议在针对&gt;= iOS10进行的修改：废弃了下面的接口： >=iOS10不会再被调用12 optional public func widgetMarginInsets(forProposedMarginInsets defaultMarginInsets: UIEdgeInsets) -&gt; UIEdgeInsets &lt;iOS10widget是默认有内容margin调节的。 补充了新的接口1234// If implemented, called when the active display mode changes.// The widget may wish to change its preferredContentSize to better accommodate the new display mode.@available(iOS 10.0, *)optional public func widgetActiveDisplayModeDidChange(_ activeDisplayMode: NCWidgetDisplayMode, withMaximumSize maxSize: CGSize)这就是点击展开/折叠按钮产生的回调，根据新的activeDisplayMode设置preferredContentSize 遇到的坑 点击展开/折叠按钮触发回调 123456if activeDisplayMode == .compact &#123; preferredContentSize = CGSize(width: viewWidth, height: 110) &#125; else &#123; setFullSize() &#125;&#125; 我们已经知道在= .compact模式下，widget的高度是定死110pt的，但是在回调中第二行的代码不可少，缺少的话会产生一种情况：从GIF中看出，即使没有第二行代码，第一次点击折叠的时候，widget正常折叠会110pt，但是接下来的点击展开/折叠，虽然activeDisplayMode在切换，但是preferredContentSize已经失效。 和情况1相似，只不过触发点不同。假设场景：widget最多显示四行四列16个model，每四个model widget增加一个高度，不超过四个model的时候隐藏展开/折叠按钮，否则显示出来。从服务请求到model数据之后，设置widgetLargestAvailableDisplayMode控制按钮的显示，但是一定要在之后设置响应状态的preferredContentSize，且最好保持这个先后顺序,开发中偶然没有按照这个先后顺序，出现了preferredContentSize无效的情况。 1-5和6-10顺序12345678910if dataSource.count &lt;= 4 &#123; extensionContext?.widgetLargestAvailableDisplayMode = .compact&#125; else &#123; extensionContext?.widgetLargestAvailableDisplayMode = .expanded&#125;if extensionContext?.widgetActiveDisplayMode == .compact &#123; preferredContentSize = CGSize(width: viewWidth, height: 110)&#125; else &#123; preferredContentSize = CGSize(width: viewWidth, height: 110 * rowCount)&#125; Widget也是一个单独的APP，但是无法进行debug，设置debugpoint，如果出现bug的话会显示无法加载，目前能想到的debug方式是添加UIlabel显示log。 写widget的时候，看了很多的文章，但是基本上都是在viewDidLoad()中设置了extensionContext?.widgetLargestAvailableDisplayMode = .expanded，其实是没有必要的，并不是必须这样的，还是要根据需求走，在合适的时机设置extensionContext?.widgetLargestAvailableDisplayMode合适的值，控制展开/折叠按钮的显示隐藏状态。 在stackoverflow看到有人提出这样问题：在不显示展开/折叠按钮的情况下，给widget设置另外一个高度(非默认110pt)的，并且提供了一个已经实现这种逻辑的APP截图，我也非常好奇怎么实现的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>widget</tag>
      </tags>
  </entry>
</search>
